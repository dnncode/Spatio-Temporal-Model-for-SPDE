#******************************************************
#******************************************************
#******************************************************
# Paper: Statistical Modeling for Spatio-Temporal Data from Physical Convection-Diffusion Processes

# ------------------------------------------------------------------------------------------
# Description (See "readme.docx" for more details): 
# This code is used to simulate the data used in the numerical example
# The initial condition is taken from a snapshot of a radar image. 
# ------------------------------------------------------------------------------------------
# Main code: 
# SPDE_Simulation_e3.R
# ------------------------------------------------------------------------------------------
# Subroutines:
# 1). SPDE_Simulation_Sub.R
# ------------------------------------------------------------------------------------------
# Data:
# 1). M2010L23S81.RData (radar image which is used to create the initial condition)
# 2). data_0313_example3_beta.RData (generated by "SPDE_Get_Beta.R")
# ------------------------------------------------------------------------------------------
# Authors: XXX
# Last revision: 06/01/2019
#******************************************************
#******************************************************
#******************************************************

rm(list = ls())    # clear workspace
set.seed(100)
#******************************************************
#******************************************************
#******************************************************
# Load Packages
#******************************************************
#******************************************************
library(sp)
library(rgdal)
library(rgeos)
library(gstat)
library(RColorBrewer)
library(spacetime)
library(mvtnorm)
library(cubature)
library(MASS)
library(Matrix)
library(spectral)
library(expm)
library(doParallel)
library(snow)
library(foreach)

n.node = 8 # number of computing nodes in the cluster/number of threads in a single machine # use the SNOW (Simple Network of Workstations) package in R for simple parallel computing
cl <- makeCluster(n.node, type = "SOCK") 
registerDoParallel(cl)
clusterEvalQ(cl, library(mvtnorm))
clusterEvalQ(cl, library(expm))


#******************************************************
#******************************************************
#******************************************************
# Basic settings
#******************************************************
#******************************************************
wd = "C:/Users/xl027/Desktop/25.SPDE_SS/code/20180814/example3/Github"
setwd(wd)
colPalette <- adjustcolor(colorRampPalette(brewer.pal(n=9, 'YlOrRd'))(100), .85)
#colPalette = rgb(r=c(0:255), g=51, b=255, maxColorValue=255, alpha=255)
colPalette.basis <-adjustcolor(colorRampPalette(brewer.pal(n=9, 'Greys'))(100), .85)
#colPalette = rgb(r=c(255:255), g=0, b=0, maxColorValue=255, alpha=255)


#******************************************************
#******************************************************
# Load processed radar data from "FFT_Radar_2.R" to construct the initial condition
#******************************************************
#******************************************************
# alpha0 (alpha0 is obtained from a radar image)
load("M2010L23S81.RData") # load a radar image data, which will be used as the initial condition
n.alpha = length(alpha)

#******************************************************
#******************************************************
# Some key parameter settings for different examples
#******************************************************
#******************************************************
zeta.para = 0.9
n.t = 40
delta.t = 0.1
noise.sigma = 0.05
para.setting = c(zeta.para, n.t, delta.t, noise.sigma)

#******************************************************
#******************************************************
# Grid settings
#******************************************************
#******************************************************
n.x = sqrt(n.alpha)  # assume n is always an even number  # from a radar image
n.y = sqrt(n.alpha)
#source("SPDE_solve_sub.R")
source("SPDE_Simulation_Sub.R") # sub-routine for data simulation
grd = grid.create(n.x = n.x, n.y=n.y, PLOT = TRUE)   # grd always on [0,1]^2
# grd is loaded from the radar image
#load("processedData/M2010L23S81.Grid.RData")
#grd = SpatialPoints(coordinates(Grid))
delta.x = 1/n.x # spatial resolution; standardized to 1
delta.y = 1/n.y
grd.original = coordinates(grd) # some original grd
grd.original = SpatialPoints(grd.original)
#x.scale = 3
#y.scale = 1
#grd.original = SpatialPoints( cbind(grd.original[,1]*x.scale,grd.original[,2]*y.scale) )
#plot(grd.original,axes=TRUE)


#******************************************************
#******************************************************
# Defined two sets of wave numbers, k1 and k2
#******************************************************
#******************************************************
k1.set = cbind(c(0,0,n.x/2,n.x/2),c(0,n.y/2,0,n.y/2))
k2.set.part1 = cbind( rep(seq(0,n.x/2,1),each=(n.y/2+1)), rep(seq(0,n.y/2,1),(n.x/2+1)))
tmp1 = paste(k1.set[,1],k1.set[,2],"-")
tmp2 = paste(k2.set.part1[,1],k2.set.part1[,2],"-")
case = which( is.na(match(tmp2, tmp1)) )
k2.set.part1 = k2.set.part1[case,]
k2.set.part2 = cbind( rep(seq(1,n.x/2-1,1),each=(n.y/2-1)), rep(seq(-1,-(n.y/2-1),-1),(n.x/2-1)))
k2.set = rbind(k2.set.part1,k2.set.part2)

# plot k1 and k2 sets on the grid
k1.set.points = SpatialPoints( k1.set )
plot(k1.set.points,pch=2,col="red",axes=TRUE,ylim=c(-n.y/2,n.y/2),xlim=c(-n.x/2,n.x/2))
k2.set.points = SpatialPoints( k2.set )
plot(k2.set.points,pch=2,col="green",add=TRUE,ylim=c(-n.y/2,n.y/2),xlim=c(-n.x/2,n.x/2))

n.k1 = nrow(k1.set)
n.k2 = nrow(k2.set)
n.k = n.k1 + n.k2# number of wave numbers
n.alpha = n.k1 + 2*n.k2# dimension of alpha

#******************************************************
#******************************************************
# calculate wave numbers, mu, and sigma which are defined on these coordinates
#******************************************************
#******************************************************
omega.1.k1 = 2*pi*k1.set[,1]
omega.2.k1 =2*pi*k1.set[,2]
omega.1.k2 = 2*pi*k2.set[,1]
omega.2.k2 =2*pi*k2.set[,2]

# cosine and sine base
tmp = lapply(c(1:n.k1), phi.c, Kx=omega.1.k1, Ky=omega.2.k1, Grd=grd)
phi.c.mat.k1 = do.call(cbind, tmp)  # the cosine values at each location for each basis
tmp = lapply(c(1:n.k1), phi.s, Kx=omega.1.k1, Ky=omega.2.k1, Grd=grd)
phi.s.mat.k1 = do.call(cbind, tmp)  # the sine values at each location for each basis

tmp = lapply(c(1:n.k2), phi.c, Kx=omega.1.k2, Ky=omega.2.k2, Grd=grd)
phi.c.mat.k2 = do.call(cbind, tmp)  # the cosine values at each location for each basis
tmp = lapply(c(1:n.k2), phi.s, Kx=omega.1.k2, Ky=omega.2.k2, Grd=grd)
phi.s.mat.k2 = do.call(cbind, tmp)  # the sine values at each location for each basis

phi.c.mat = cbind(phi.c.mat.k1,phi.c.mat.k2)
phi.s.mat = cbind(phi.s.mat.k1,phi.s.mat.k2)


if (FALSE){ # plot of the 
  i = 4
  #par(mfrow=c(1,2))
  cos.spdf = SpatialPixelsDataFrame(grd, data.frame(phi.c.mat.k1[,i]))
  plot(grd, axes=TRUE,col="grey",xlim=c(0,1),ylim=c(0,1))
  image(cos.spdf , add=TRUE, col=colPalette.basis)
  plot(grd, col="red",xlim=c(0,1),ylim=c(0,1),add=TRUE)
}
if (FALSE){ # plot of the 
  i = 20
  par(mfrow=c(1,2))
  cos.spdf = SpatialPixelsDataFrame(grd, data.frame(phi.c.mat.k2[,i]))
  plot(grd, axes=TRUE,col="grey",xlim=c(0,1),ylim=c(0,1))
  image(cos.spdf , add=TRUE, col=colPalette.basis)
  plot(grd, col="red",xlim=c(0,1),ylim=c(0,1),add=TRUE)
  
  sin.spdf = SpatialPixelsDataFrame(grd, data.frame(phi.s.mat.k2[,i]))
  plot(grd, axes=TRUE,col="grey",xlim=c(0,1),ylim=c(0,1))
  image(sin.spdf , add=TRUE, col=colPalette.basis)
  plot(grd, col="red",xlim=c(0,1),ylim=c(0,1),add=TRUE)
}
if (FALSE){ # plot for the paper, figure 3
  png(filename = "../../figures/figure3.png",
      width = 6, height = 2, unit="in", pointsize = 12,
      bg = "white", res = 600)
  
  par(mfrow = c(1, 3))
  par(las=TRUE)
  par(mar=c(4,4,1,1))
  
  i = 4
  #par(mfrow=c(1,2))
  cos.spdf = SpatialPixelsDataFrame(grd, data.frame(phi.c.mat.k1[,i]))
  image(cos.spdf, col=colPalette.basis,xlim=c(0,1),ylim=c(0,1),
        xlab=expression("s"[1]),ylab=expression("s"[2]),axes=TRUE)
  
  i = 40
  cos.spdf = SpatialPixelsDataFrame(grd, data.frame(phi.c.mat.k2[,i]))
  image(cos.spdf , col=colPalette.basis,xlim=c(0,1),ylim=c(0,1),
        xlab=expression("s"[1]),ylab=expression("s"[2]),axes=TRUE)
  
  i = 50
  sin.spdf = SpatialPixelsDataFrame(grd, data.frame(phi.s.mat.k2[,i]))
  image(sin.spdf , col=colPalette.basis,xlim=c(0,1),ylim=c(0,1),
        xlab=expression("s"[1]),ylab=expression("s"[2]),axes=TRUE)

  dev.off()
}


#******************************************************
#******************************************************
# Calculate mu and sigma 
#******************************************************
#******************************************************

# there are two approaches to get the mu, sigma, and div.sigma

# approach 1: used for example 1; 
# mu, sigma, div.sigma are given in their parametric form:

# get mu and sigma
if (FALSE){
  tmp = lapply(c(1:(n.x*n.y)), mu_fun, x.Coords=coordinates(grd)[,1], y.Coords=coordinates(grd)[,2])
  mu = do.call(rbind, tmp)  # a n^2 by 2 matrix
  if (FALSE){
    plot(grd)
    arrows(coordinates(grd)[,1],coordinates(grd)[,2],
           coordinates(grd)[,1]+mu[,1]/2,
           coordinates(grd)[,2]+mu[,2]/2,length=0.05,col="darkgreen",lwd=1)
  }
  #mu.speed = sqrt( mu[,1]^2+mu[,2]^2 )
  sigma = lapply(c(1:(n.x*n.y)), s_fun, 
                 x.Coords=coordinates(grd)[,1], y.Coords=coordinates(grd)[,2], 
                 Mu = mu) # a n^2 list, for each list, 2 by 2 matrix
  for (i in 1:(n.x*n.y)){
    sigma[[i]][1,1] = mu[i,1] *sigma[[i]][1,1]
    sigma[[i]][2,2] = mu[i,2] *sigma[[i]][2,2]
  }
  div.sigma = list()
  for (i in 1:(n.x*n.y)){
    #div.sigma[[i]] = matrix(c(0,0),nrow=1) # this is the case when Sigma does not vary
    div.sigma[[i]] = matrix(c(-0.1,0.1),nrow=1) # this is for the numerical example
  }
  # the divergence of sigma; a n^2 list, for each list, 1 by 2 vector
}

# approach 2: used for the numerical example
# mu, sigma, div.sigma are given by kernel approximation

if (TRUE){
  set.seed(1)
  J = 6 # number of Kernels (even). 
  
  Gamma_x = rnorm(J*3,0,0.1)/2
  Gamma_y = rnorm(J*3,0,0.1)/2
  para=c(Gamma_x,Gamma_y,0.01,0.98,0.01,0.01)
  para=c(Gamma_x,Gamma_y,log(1),0.98,log(0.01),log(0.01))
  
  k.center=kmeans(coordinates(grd.original), J)$centers
  # kernel functions; bi-variate normal; sigma = 0.5 (half with)
  kernel.list = list()
  FF = cbind(rep(1,length(grd.original)),coordinates(grd.original)) 
  X.list=list()
  kernel.sigma = 0.25
  for (j in 1:J){
    kernel.list[[j]] = dmvnorm(coordinates(grd.original), mean=c(k.center[j,1],k.center[j,2]), 
                               sigma=matrix( c(kernel.sigma,0,0,kernel.sigma),ncol=2), log=FALSE)
    X.list[[j]] = diag(kernel.list[[j]] ) %*% FF
  }
  X = do.call(cbind,X.list)
  
  mu = convection_fun_1(X.input=X, gamma_x=para[1:(3*J)],gamma_y=para[(3*J+1):(6*J)])
  #mu = mu/2 # in example 2, adjust the scale of mu
  if (TRUE){
    plot(grd)
    arrows(coordinates(grd)[,1],coordinates(grd)[,2],
           coordinates(grd)[,1]+mu[,1],
           coordinates(grd)[,2]+mu[,2],length=0.05,col="darkgreen",lwd=1)
  }
  
  r.diffusion = exp(para[6*J+1])
  sigma = lapply(c(1:(n.x*n.y)), diffusion_fun, r=r.diffusion,
                 x.Coords=coordinates(grd.original)[,1], y.Coords=coordinates(grd.original)[,2], 
                 Mu = mu) # a n^2 list, for each list, 2 by 2 matrix
  for (i in 1:(n.x*n.y)){
    sigma[[i]][1,1] = mu[i,1] *sigma[[i]][1,1]
    sigma[[i]][2,2] = mu[i,2] *sigma[[i]][2,2]
  }
  div.sigma = list()
  tmp = solve(matrix( c(kernel.sigma,0,0,kernel.sigma),ncol=2))
  for (i in 1:(n.x*n.y)){
    x = coordinates(grd.original)[i,1]
    y = coordinates(grd.original)[i,2]
    tmp2 = tmp3 = list()
    for (j in 1:J){
      term1 = -kernel.list[[j]][i] * tmp[1,1] * (x-k.center[j,1])
      term2 = (term1*x + kernel.list[[j]][i] )
      term3 = (term1*y)
      tmp2[[j]] = matrix( c(term1, term2, term3),nrow=1 )
      
      term4 = -kernel.list[[j]][i] * tmp[2,2] * (x-k.center[j,2])
      term5 = (term4*x)
      term6 = (term4*y + kernel.list[[j]][i] )
      tmp3[[j]] = matrix( c(term4, term5, term6),nrow=1 )
    }
    tmp2 = do.call(cbind, tmp2)
    tmp3 = do.call(cbind, tmp3)
    tmp2 = tmp2%*%matrix(Gamma_x,ncol=1)
    tmp3 = tmp3%*%matrix(Gamma_y,ncol=1)
    
    div.sigma[[i]] = matrix(c(tmp2*r.diffusion,tmp3*r.diffusion),nrow=1)
  }
}


#******************************************************
#******************************************************
# zeta
#******************************************************
#******************************************************
# the model allows zeta to vary in both space and time; 
# but since mu and sigma only vary in space; 
# the following code only allow zeta to vary in space
zeta = array(zeta.para,dim=c((n.x*n.y),1))



#******************************************************
#******************************************************
# process simulation:
#******************************************************
#******************************************************
C = 1/2 # the constant term

#******************************************************
# the transition matrix g related to mu (convection)
#******************************************************
g.mat.1 = array(0/0, dim=c(n.alpha, n.alpha))  # the transition matrix g related to MU 
#tmp.s = proc.time()
dummy = foreach(ll=1:4) %dopar% {
  aa = sapply(1:n.k1, My.fun1,l=ll, Mu=mu, Kx=omega.1.k1, Ky=omega.2.k1, 
              base1=phi.c.mat.k1, base2=phi.s.mat.k1, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y) / C
  bb= 2* sapply(1:n.k2, My.fun1,l=ll, Mu=mu, Kx=omega.1.k2, Ky=omega.2.k2, 
                base1=phi.c.mat.k1, base2=phi.s.mat.k2, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y) / C
  cc = - 2*sapply(1:n.k2, My.fun1,l=ll, Mu=mu, Kx=omega.1.k2, Ky=omega.2.k2, 
                  base1=phi.c.mat.k1, base2=phi.c.mat.k2, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y) / C
  return(c(aa,bb,cc))
}
g.mat.1[1:4,] = do.call(rbind,dummy)
dummy = foreach(ll = (n.k1+n.k2+1):n.alpha) %dopar% {
  aa = sapply(1:n.k1, My.fun1,l=(ll-n.k1-n.k2), Mu=mu, Kx=omega.1.k1, Ky=omega.2.k1, 
              base1=phi.s.mat.k2, base2=phi.c.mat.k1, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y) / (2*C)
  bb = 2* sapply(1:n.k2, My.fun1,l=(ll-n.k1-n.k2), Mu=mu, Kx=omega.1.k2, Ky=omega.2.k2, 
                 base1=phi.s.mat.k2, base2=phi.s.mat.k2, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y)/ (2*C)
  cc = - 2*sapply(1:n.k2, My.fun1,l=(ll-n.k1-n.k2), Mu=mu, Kx=omega.1.k2, Ky=omega.2.k2, 
                  base1=phi.s.mat.k2, base2=phi.c.mat.k2, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y)/ (2*C)
  return(c(aa,bb,cc))
}
g.mat.1[(n.k1+n.k2+1):n.alpha,] = do.call(rbind,dummy)
dummy = foreach(ll = 5:(n.k1+n.k2)) %dopar% {
  aa = sapply(1:n.k1, My.fun1,l=(ll-n.k1), Mu=mu, Kx=omega.1.k1, Ky=omega.2.k1, 
              base1=phi.c.mat.k2, base2=phi.s.mat.k1, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y) / (2*C)
  bb = 2* sapply(1:n.k2, My.fun1,l=(ll-n.k1), Mu=mu, Kx=omega.1.k2, Ky=omega.2.k2, 
                 base1=phi.c.mat.k2, base2=phi.s.mat.k2, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y)/ (2*C)
  cc = - 2*sapply(1:n.k2, My.fun1,l=(ll-n.k1), Mu=mu, Kx=omega.1.k2, Ky=omega.2.k2, 
                  base1=phi.c.mat.k2, base2=phi.c.mat.k2, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y)/ (2*C)
  return(c(aa,bb,cc))
}
g.mat.1[5:(n.k1+n.k2),] = do.call(rbind,dummy)
dim(g.mat.1)



#******************************************************
# the transition matrix g related to Sigma(diffusion)
#******************************************************
g.mat.2 = array(0/0, dim=c(n.alpha, n.alpha))  # the transition matrix g related to mu 

dummy = foreach(ll=1:4) %dopar% {
  aa = sapply(1:n.k1, My.fun2,l=ll, Sigma=sigma, Div.Sigma=div.sigma, Kx=omega.1.k1, Ky=omega.2.k1, 
                              base1=phi.c.mat.k1, base2.c=phi.c.mat.k1, base2.s=phi.s.mat.k1, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y) / C
  bb = 2*sapply(1:n.k2, My.fun2,l=ll, Sigma=sigma, Div.Sigma=div.sigma, Kx=omega.1.k2, Ky=omega.2.k2, 
                                              base1=phi.c.mat.k1, base2.c=phi.c.mat.k2, base2.s=phi.s.mat.k2, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y) / C
  cc = 2*sapply(1:n.k2, My.fun3,l=ll, Sigma=sigma, Div.Sigma=div.sigma, Kx=omega.1.k2, Ky=omega.2.k2, 
                                                     base1=phi.s.mat.k1, base2.c=phi.c.mat.k2, base2.s=phi.s.mat.k2, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y) / C
  return(c(aa,bb,cc))
}
g.mat.2[1:4,] = do.call(rbind,dummy)

dummy = foreach(ll = (n.k1+n.k2+1):n.alpha) %dopar% {
  aa= sapply(1:n.k1, My.fun2,l=(ll-n.k1-n.k2), Sigma=sigma, Div.Sigma=div.sigma, Kx=omega.1.k1, Ky=omega.2.k1, 
                              base1=phi.s.mat.k2, base2.c=phi.c.mat.k1, base2.s=phi.s.mat.k1, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y)  / (2*C)
  bb= 2* sapply(1:n.k2, My.fun2,l=(ll-n.k1-n.k2), Sigma=sigma, Div.Sigma=div.sigma, Kx=omega.1.k2, Ky=omega.2.k2, 
                                               base1=phi.s.mat.k2, base2.c=phi.c.mat.k2, base2.s=phi.s.mat.k2, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y) / (2*C)
  cc = 2*sapply(1:n.k2, My.fun3,l=(ll-n.k1-n.k2), Sigma=sigma, Div.Sigma=div.sigma, Kx=omega.1.k2, Ky=omega.2.k2, 
                                                     base1=phi.s.mat.k2, base2.c=phi.c.mat.k2, base2.s=phi.s.mat.k2, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y) / (2*C)
  return(c(aa,bb,cc))
}
g.mat.2[(n.k1+n.k2+1):n.alpha,] = do.call(rbind,dummy)

dummy = foreach(ll = 5:(n.k1+n.k2)) %dopar% {
  aa = sapply(1:n.k1, My.fun2,l=(ll-n.k1), Sigma=sigma, Div.Sigma=div.sigma, Kx=omega.1.k1, Ky=omega.2.k1, 
                              base1=phi.c.mat.k2, base2.c=phi.c.mat.k1, base2.s=phi.s.mat.k1, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y) / (2*C)
  bb = 2* sapply(1:n.k2, My.fun2,l=(ll-n.k1),Sigma=sigma, Div.Sigma=div.sigma, Kx=omega.1.k2, Ky=omega.2.k2, 
                                               base1=phi.c.mat.k2, base2.c=phi.c.mat.k2, base2.s=phi.s.mat.k2, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y)/ (2*C)
  cc =  2*sapply(1:n.k2, My.fun3,l=(ll-n.k1), Sigma=sigma, Div.Sigma=div.sigma, Kx=omega.1.k2, Ky=omega.2.k2, 
                                                      base1=phi.c.mat.k2, base2.c=phi.c.mat.k2, base2.s=phi.s.mat.k2, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y)/ (2*C)
  return(c(aa,bb,cc))
}
g.mat.2[5:(n.k1+n.k2),] = do.call(rbind,dummy)


#******************************************************
# the transition matrix g related to Zeta
#******************************************************
g.mat.3 = array(0/0, dim=c(n.alpha, n.alpha))  # the transition matrix g related to mu 

dummy = foreach(ll=1:4) %dopar% {
  aa = sapply(1:n.k1, My.fun4,l=ll, Zeta = zeta,  
                              base1=phi.c.mat.k1, base2=phi.c.mat.k1, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y) / C
  bb = 2*sapply(1:n.k2, My.fun4,l=ll, Zeta = zeta,
                                              base1=phi.c.mat.k1, base2=phi.c.mat.k2, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y) / C
  cc = 2*sapply(1:n.k2, My.fun4,l=ll, Zeta = zeta,
                                                     base1=phi.c.mat.k1, base2=phi.s.mat.k2, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y) / C
  return(c(aa,bb,cc))
}
g.mat.3[1:4,] = do.call(rbind,dummy)

dummy = foreach(ll = (n.k1+n.k2+1):n.alpha) %dopar% {
  aa = sapply(1:n.k1, My.fun4,l=(ll-n.k1-n.k2), Zeta = zeta,
                              base1=phi.s.mat.k2, base2=phi.c.mat.k1, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y) / (2*C)
  bb = 2* sapply(1:n.k2, My.fun4,l=(ll-n.k1-n.k2), Zeta = zeta,
                                               base1=phi.s.mat.k2, base2=phi.c.mat.k2, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y)/ (2*C)
  cc= 2*sapply(1:n.k2, My.fun4,l=(ll-n.k1-n.k2), Zeta = zeta,
                                                     base1=phi.s.mat.k2, base2=phi.s.mat.k2, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y)/ (2*C)
  return(c(aa,bb,cc))
}
g.mat.3[(n.k1+n.k2+1):n.alpha,] = do.call(rbind,dummy)

dummy = foreach(ll = 5:(n.k1+n.k2)) %dopar% {
  aa = sapply(1:n.k1, My.fun4,l=(ll-n.k1), Zeta = zeta,
                              base1=phi.c.mat.k2, base2=phi.c.mat.k1, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y) / (2*C)
  bb = 2* sapply(1:n.k2, My.fun4,l=(ll-n.k1), Zeta = zeta,
                                               base1=phi.c.mat.k2, base2=phi.c.mat.k2, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y)/ (2*C)
  cc = 2*sapply(1:n.k2, My.fun4,l=(ll-n.k1), Zeta = zeta,
                                                     base1=phi.c.mat.k2, base2=phi.s.mat.k2, N=(n.x*n.y), Ds.x = delta.x, Ds.y=delta.y)/ (2*C)
  return(c(aa,bb,cc))
}
g.mat.3[5:(n.k1+n.k2),] = do.call(rbind,dummy)


#******************************************************
# the transition matrix g related to generation, q
#******************************************************
load("data_0313_example3_beta.RData") 
# load the Fourier coefficients for the source-sink term, which are pre-calculated by "SPDE_Get_Beta.R"


#******************************************************
# the transition matrix G
#******************************************************
G = g.mat.1 + g.mat.2 + g.mat.3


#******************************************************
# noise of alpha over the interval, delta.t
#******************************************************
H = diag( noise.sigma, nrow(G))
interval.t = seq(delta.t/50/2, delta.t, delta.t/50)
if (TRUE){  # parallel foreach
  dummy = foreach(i=1:length(interval.t)) %dopar% {
    tau = interval.t[i]
    aa = as.matrix( expm(G*(delta.t-tau)) )  %*% H %*% (as.matrix( expm(t(G)*(delta.t-tau)) ) )
    return(aa)
  }
  S_W = Reduce("+", dummy) * delta.t/50
}
#noise = rmvnorm(n.alpha, 0, noise.sigma)
noise =rmvnorm(1, mean = rep(0, n.alpha), sigma = S_W)
noise = matrix(noise,ncol=1)

#******************************************************
# Simulation
#******************************************************


alpha0 = alpha + Beta[,1]
alpha0 = matrix(alpha0, ncol=1)
#alpha0 = rnorm(n.alpha, 0, 0.3)
#alpha0 = matrix(alpha0, ncol=1)

#n.t = 40
KSI.matrix = array(0/0,dim=c(length(grd),n.t))

# Simulation:
# Process:
ksi0 = ksi = array(0/0,dim=c(length(grd),1))
for (i in 1:length(grd)){
  term1 = phi.c.mat.k1[i,] %*% alpha0[1:n.k1,1] 
  term2 = 2*phi.c.mat.k2[i,] %*% alpha0[(n.k1+1):(n.k1+n.k2),1] 
  term3 = 2*phi.s.mat.k2[i,] %*% alpha0[(n.k1+n.k2+1):(n.k1+2*n.k2),1] 
  ksi0[i,1] =  term1 + term2 + term3
}
ksi0[ksi0<0] = 0

if (TRUE){
  ksi.spdf = SpatialPixelsDataFrame(grd, data.frame(as.matrix(ksi0)))
  plot(grd, axes=TRUE,col="grey",xlim=c(0,1),ylim=c(0,1))
  image(ksi.spdf, add=TRUE, col=colPalette)
  #plot(grd, col="red",xlim=c(0,1),ylim=c(0,1),add=TRUE)
}
if (FALSE){
  rasterImage2(x = sort(unique(coordinates(grd)[,1])),
               y = sort(unique(coordinates(grd)[,2])),
               z = (t(matrix(as.matrix(ksi0),nrow=n.y))))
}
KSI.matrix[,1] = ksi0

# alpha evolution
alpha.old = alpha0
# evolution starts here
#delta.t = 1


for (j in 2:n.t){
  noise =rmvnorm(1, mean = rep(0, n.alpha), sigma = S_W)
  noise = matrix(noise,ncol=1)
  alpha.new = expm(delta.t * G) %*% alpha.old + Beta[,j] +  noise
  #alpha.new = matrix(noise,ncol=1)
  #alpha.new = expm(delta.t * G) %*% alpha.old 
  for (i in 1:length(grd)){
    term1 = phi.c.mat.k1[i,] %*% alpha.new[1:n.k1,1] 
    term2 = 2*phi.c.mat.k2[i,] %*% alpha.new[(n.k1+1):(n.k1+n.k2),1] 
    term3 = 2*phi.s.mat.k2[i,] %*% alpha.new[(n.k1+n.k2+1):(n.k1+2*n.k2),1] 
    ksi[i,1] =  term1 + term2 + term3 
  }
  ksi[ksi<0] = 0
  
  if (FALSE){
  rasterImage2(x = sort(unique(coordinates(grd)[,1])),
               y = sort(unique(coordinates(grd)[,2])),
               z = (t(matrix(as.matrix(ksi),nrow=n.y))))
  alpha.old = alpha.new 
  range(ksi)
  }
  
  if (TRUE){
    ksi.spdf = SpatialPixelsDataFrame(grd, data.frame(as.matrix(ksi)))
    plot(grd, axes=TRUE,col="grey",xlim=c(0,1),ylim=c(0,1))
    image(ksi.spdf, add=TRUE, col=colPalette)
    plot(grd, col="red",xlim=c(0,1),ylim=c(0,1),add=TRUE)
    alpha.old = alpha.new 
    arrows(coordinates(grd)[,1],coordinates(grd)[,2],
           coordinates(grd)[,1]+mu[,1]/2,
           coordinates(grd)[,2]+mu[,2]/2,length=0.05,col="darkgreen",lwd=1)
    range(ksi)
  }
  
  KSI.matrix[,j] = ksi
  print(j)
  print(range(ksi))
}


#******************************************************
# Output
#******************************************************
data = KSI.matrix
if (FALSE){
  save(data, file="data_0313_example3_ksi.RData")
  save(grd.original, file="data_0313_example3_grd_original.RData")
  save(G, file="data_0313_example3_G.RData")
  save(noise, file="data_0313_example3_Noise.RData")
  save.image("data_0313_example3.RData")
}




